<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - Point Set Processing: Algorithms</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - Point Set Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__PkgPointSetProcessing3Algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms<div class="ingroups"><a class="el" href="group__PkgPointSetProcessing3Ref.html">Point Set Processing Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>Collection of algorithms of point set processing (smoothing, simplification, etc.). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html">CGAL::pointmatcher::ICP_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code> is designed to handle preparing and passing configurations to the registration methods <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaf75af5c1634fa83fa05a33e95570b127">CGAL::pointmatcher::compute_registration_transformation()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa222278e20a3ce41930d37326cd54ef9">CGAL::pointmatcher::register_point_sets()</a></code>.  <a href="structCGAL_1_1pointmatcher_1_1ICP__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Point__set__with__structure.html">CGAL::Point_set_with_structure&lt; Kernel &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D point set with structure information based on a set of detected planes.  <a href="classCGAL_1_1Point__set__with__structure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4f82723e2f0bb33f3677e29e0208a256"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga4f82723e2f0bb33f3677e29e0208a256"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4f82723e2f0bb33f3677e29e0208a256">CGAL::bilateral_smooth_point_set</a> (PointRange &amp;points, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga4f82723e2f0bb33f3677e29e0208a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee41d60b5a257ae034e9157d0af8e46"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename ClusterMap , typename NamedParameters &gt; </td></tr>
<tr class="memitem:gafee41d60b5a257ae034e9157d0af8e46"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafee41d60b5a257ae034e9157d0af8e46">CGAL::cluster_point_set</a> (PointRange &amp;points, ClusterMap cluster_map, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gafee41d60b5a257ae034e9157d0af8e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa74cb0739e0d74f495d3a65e7e1b4e7e"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename CGAL_BGL_NP_TEMPLATE_PARAMETERS &gt; </td></tr>
<tr class="memitem:gaa74cb0739e0d74f495d3a65e7e1b4e7e"><td class="memTemplItemLeft" align="right" valign="top">FT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa74cb0739e0d74f495d3a65e7e1b4e7e">CGAL::compute_average_spacing</a> (const PointRange &amp;points, unsigned int k, const CGAL_BGL_NP_CLASS &amp;np)</td></tr>
<tr class="separator:gaa74cb0739e0d74f495d3a65e7e1b4e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga128b4cd2445490a0f1c3f573216ac477"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename OutputIterator , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga128b4cd2445490a0f1c3f573216ac477"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga128b4cd2445490a0f1c3f573216ac477">CGAL::edge_aware_upsample_point_set</a> (const PointRange &amp;points, OutputIterator output, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga128b4cd2445490a0f1c3f573216ac477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b8b073db1b79e1cc482114044fd76c"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename QueryPointRange , typename OutputIterator , typename NamedParameters &gt; </td></tr>
<tr class="memitem:gab8b8b073db1b79e1cc482114044fd76c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gab8b8b073db1b79e1cc482114044fd76c">CGAL::estimate_local_k_neighbor_scales</a> (const PointRange &amp;points, const QueryPointRange &amp;queries, OutputIterator output, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gab8b8b073db1b79e1cc482114044fd76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0e851fd41f7ea2c640eff9f5a3fc2b"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga7a0e851fd41f7ea2c640eff9f5a3fc2b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7a0e851fd41f7ea2c640eff9f5a3fc2b">CGAL::estimate_global_k_neighbor_scale</a> (const PointRange &amp;points, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga7a0e851fd41f7ea2c640eff9f5a3fc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9353050636f6c746585639a282a7b8"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename QueryPointRange , typename OutputIterator , typename NamedParameters &gt; </td></tr>
<tr class="memitem:gacc9353050636f6c746585639a282a7b8"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gacc9353050636f6c746585639a282a7b8">CGAL::estimate_local_range_scales</a> (const PointRange &amp;points, const QueryPointRange &amp;queries, OutputIterator output, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gacc9353050636f6c746585639a282a7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8e7e8e694d746cfa0bca11f87fb527"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga8b8e7e8e694d746cfa0bca11f87fb527"><td class="memTemplItemLeft" align="right" valign="top">FT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8b8e7e8e694d746cfa0bca11f87fb527">CGAL::estimate_global_range_scale</a> (const PointRange &amp;points, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga8b8e7e8e694d746cfa0bca11f87fb527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c81cc8a2986e3972e86612e4f847a1"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:gac7c81cc8a2986e3972e86612e4f847a1"><td class="memTemplItemLeft" align="right" valign="top">PointRange::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac7c81cc8a2986e3972e86612e4f847a1">CGAL::grid_simplify_point_set</a> (PointRange &amp;points, double epsilon, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gac7c81cc8a2986e3972e86612e4f847a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149ceecc075a180669bde3e65742fdf5"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga149ceecc075a180669bde3e65742fdf5"><td class="memTemplItemLeft" align="right" valign="top">PointRange::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga149ceecc075a180669bde3e65742fdf5">CGAL::hierarchy_simplify_point_set</a> (PointRange &amp;points, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga149ceecc075a180669bde3e65742fdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd0f87de690d4edf82740e856efa491"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga0cd0f87de690d4edf82740e856efa491"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga0cd0f87de690d4edf82740e856efa491">CGAL::jet_estimate_normals</a> (PointRange &amp;points, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga0cd0f87de690d4edf82740e856efa491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga549402c0a8a8b6b71875181e93961521"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga549402c0a8a8b6b71875181e93961521"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga549402c0a8a8b6b71875181e93961521">CGAL::jet_smooth_point_set</a> (PointRange &amp;points, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga549402c0a8a8b6b71875181e93961521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c98d5c5ae5535bce6f32eddbd03f33"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga50c98d5c5ae5535bce6f32eddbd03f33"><td class="memTemplItemLeft" align="right" valign="top">PointRange::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c98d5c5ae5535bce6f32eddbd03f33">CGAL::mst_orient_normals</a> (PointRange &amp;points, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga50c98d5c5ae5535bce6f32eddbd03f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab81663c718960780ddb176aad845e8cd"><td class="memTemplParams" colspan="2">template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </td></tr>
<tr class="memitem:gab81663c718960780ddb176aad845e8cd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; geom_traits::Aff_transformation_3, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gab81663c718960780ddb176aad845e8cd">CGAL::OpenGR::compute_registration_transformation</a> (const PointRange1 &amp;point_set_1, const PointRange2 &amp;point_set_2, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2)</td></tr>
<tr class="separator:gab81663c718960780ddb176aad845e8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6e7a9531de6f6a1746fbc78cc2f47a"><td class="memTemplParams" colspan="2">template&lt;class PointRange , class CorrespondencesRange , class NamedParameters , class TransformRange &gt; </td></tr>
<tr class="memitem:ga1e6e7a9531de6f6a1746fbc78cc2f47a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga1e6e7a9531de6f6a1746fbc78cc2f47a">CGAL::OpenGR::compute_registration_transformations</a> (const std::vector&lt; PointRange &gt; &amp;point_clouds, const CorrespondencesRange &amp;correspondences, const int num_global_coordinates, const NamedParameters &amp;np, TransformRange &amp;transformations)</td></tr>
<tr class="separator:ga1e6e7a9531de6f6a1746fbc78cc2f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ed21b37f02e0f36497c69f687b2fad"><td class="memTemplParams" colspan="2">template&lt;class PointRange , class CorrespondencesRange , class NamedParameters &gt; </td></tr>
<tr class="memitem:gae9ed21b37f02e0f36497c69f687b2fad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gae9ed21b37f02e0f36497c69f687b2fad">CGAL::OpenGR::register_point_clouds</a> (const std::vector&lt; PointRange &gt; &amp;point_clouds, const CorrespondencesRange &amp;correspondences, const int num_global_coordinates, const NamedParameters &amp;np, PointRange &amp;registered_points)</td></tr>
<tr class="separator:gae9ed21b37f02e0f36497c69f687b2fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6194087f512e4e23dd945a9364d0931d"><td class="memTemplParams" colspan="2">template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </td></tr>
<tr class="memitem:ga6194087f512e4e23dd945a9364d0931d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga6194087f512e4e23dd945a9364d0931d">CGAL::OpenGR::register_point_sets</a> (const PointRange1 &amp;point_set_1, PointRange2 &amp;point_set_2, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2)</td></tr>
<tr class="separator:ga6194087f512e4e23dd945a9364d0931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c642da96a025ab32445aeb6cc219b0b"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga8c642da96a025ab32445aeb6cc219b0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8c642da96a025ab32445aeb6cc219b0b">CGAL::pca_estimate_normals</a> (PointRange &amp;points, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga8c642da96a025ab32445aeb6cc219b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75af5c1634fa83fa05a33e95570b127"><td class="memTemplParams" colspan="2">template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </td></tr>
<tr class="memitem:gaf75af5c1634fa83fa05a33e95570b127"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; geom_traits::Aff_transformation_3, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaf75af5c1634fa83fa05a33e95570b127">CGAL::pointmatcher::compute_registration_transformation</a> (const PointRange1 &amp;point_set_1, const PointRange2 &amp;point_set_2, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2)</td></tr>
<tr class="separator:gaf75af5c1634fa83fa05a33e95570b127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa222278e20a3ce41930d37326cd54ef9"><td class="memTemplParams" colspan="2">template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </td></tr>
<tr class="memitem:gaa222278e20a3ce41930d37326cd54ef9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa222278e20a3ce41930d37326cd54ef9">CGAL::pointmatcher::register_point_sets</a> (const PointRange1 &amp;point_set_1, PointRange2 &amp;point_set_2, const NamedParameters1 &amp;np1, const NamedParameters2 &amp;np2)</td></tr>
<tr class="separator:gaa222278e20a3ce41930d37326cd54ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be2d94f1791d24b8ba0107bc33ad6dc"><td class="memTemplParams" colspan="2">template&lt;typename PointRange &gt; </td></tr>
<tr class="memitem:ga4be2d94f1791d24b8ba0107bc33ad6dc"><td class="memTemplItemLeft" align="right" valign="top">PointRange::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc">CGAL::random_simplify_point_set</a> (PointRange &amp;points, double removed_percentage)</td></tr>
<tr class="separator:ga4be2d94f1791d24b8ba0107bc33ad6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab1dcee59caadde50572c5a504cc41a"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga1ab1dcee59caadde50572c5a504cc41a"><td class="memTemplItemLeft" align="right" valign="top">PointRange::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga1ab1dcee59caadde50572c5a504cc41a">CGAL::remove_outliers</a> (PointRange &amp;points, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga1ab1dcee59caadde50572c5a504cc41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbc04909dfd575a94f932c8d3bacdce"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename PlaneRange , typename OutputIterator , typename NamedParameters &gt; </td></tr>
<tr class="memitem:gaebbc04909dfd575a94f932c8d3bacdce"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce">CGAL::structure_point_set</a> (const PointRange &amp;points, const PlaneRange &amp;planes, OutputIterator output, double epsilon, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gaebbc04909dfd575a94f932c8d3bacdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57ce53e3249a66e4c19e85f439ff01e"><td class="memTemplParams" colspan="2">template&lt;class FT , class VCMTraits &gt; </td></tr>
<tr class="memitem:gac57ce53e3249a66e4c19e85f439ff01e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e">CGAL::vcm_is_on_feature_edge</a> (std::array&lt; FT, 6 &gt; &amp;cov, double threshold, VCMTraits)</td></tr>
<tr class="separator:gac57ce53e3249a66e4c19e85f439ff01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4090777b535d58b5acf30ab7fb7cf488"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga4090777b535d58b5acf30ab7fb7cf488"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4090777b535d58b5acf30ab7fb7cf488">CGAL::compute_vcm</a> (const PointRange &amp;points, std::vector&lt; std::array&lt; double, 6 &gt; &gt; &amp;ccov, double offset_radius, double convolution_radius, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga4090777b535d58b5acf30ab7fb7cf488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020a2ee77849fc70cbbee93358222dff"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga020a2ee77849fc70cbbee93358222dff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga020a2ee77849fc70cbbee93358222dff">CGAL::vcm_estimate_normals</a> (PointRange &amp;points, double offset_radius, double convolution_radius, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga020a2ee77849fc70cbbee93358222dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0104e0562c13b009bc698b20f378c3"><td class="memTemplParams" colspan="2">template&lt;typename PointRange , typename NamedParameters &gt; </td></tr>
<tr class="memitem:ga6c0104e0562c13b009bc698b20f378c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga6c0104e0562c13b009bc698b20f378c3">CGAL::vcm_estimate_normals</a> (PointRange &amp;points, double offset_radius, unsigned int k, const NamedParameters &amp;np)</td></tr>
<tr class="separator:ga6c0104e0562c13b009bc698b20f378c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbddbfa4e9c4c32c42d981a6a050d8cd"><td class="memTemplParams" colspan="2">template&lt;typename ConcurrencyTag , typename PointRange , typename OutputIterator , typename NamedParameters &gt; </td></tr>
<tr class="memitem:gacbddbfa4e9c4c32c42d981a6a050d8cd"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gacbddbfa4e9c4c32c42d981a6a050d8cd">CGAL::wlop_simplify_and_regularize_point_set</a> (PointRange &amp;points, OutputIterator output, const NamedParameters &amp;np)</td></tr>
<tr class="separator:gacbddbfa4e9c4c32c42d981a6a050d8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4f82723e2f0bb33f3677e29e0208a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f82723e2f0bb33f3677e29e0208a256">&#9670;&nbsp;</a></span>bilateral_smooth_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double CGAL::bilateral_smooth_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/bilateral_smooth_point_set.h&gt;</code></p>
<p>This function smooths an input point set by iteratively projecting each point onto the implicit surface patch fitted over its nearest neighbors. Bilateral projection preserves sharp features according to the normal (gradient) information. Both point positions and normals will be modified. For more details, please see section 4 in <a class="el" href="citelist.html#CITEREF_ear-2013">[6]</a>.</p>
<p>A parallel version of this function is provided and requires the executable to be linked against the <a href="https://www.threadingbuildingblocks.org">Intel TBB library</a>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <a href="https://www.threadingbuildingblocks.org/documentation">TBB documentation</a> for more details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Normals must be unit vectors </dd>
<dd>
k &gt;= 2</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>size of the neighborhood for the implicit surface patch fitting. The larger the value is, the smoother the result will be. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If provided, the neighborhood of a query point is computed with a fixed spherical radius instead of a fixed number of neighbors. In that case, the parameter <code>k</code> is used as a limit on the number of points returned by each spherical query (to avoid overly large number of points in high density areas). If no limit is wanted, use <code>k=0</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_sharpness_angle">sharpness_angle</a></td><td>controls the sharpness of the result. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped, all points are left unchanged and the function return <code>NaN</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Average point movement error. It's a convergence criterium for the algorithm. This value can help the user to decide how many iterations are sufficient. </dd></dl>

</div>
</div>
<a id="gafee41d60b5a257ae034e9157d0af8e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafee41d60b5a257ae034e9157d0af8e46">&#9670;&nbsp;</a></span>cluster_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename ClusterMap , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::cluster_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClusterMap&#160;</td>
          <td class="paramname"><em>cluster_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/cluster_point_set.h&gt;</code></p>
<p>Identifies connected components on a nearest neighbor graph built using a query sphere of fixed radius centered on each point.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>. </td></tr>
    <tr><td class="paramname">ClusterMap</td><td>is a model of <code>ReadWritePropertyMap</code> with value type <code>std::size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">cluster_map</td><td>maps each point to the index of the cluster it belongs to. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and the number of already computed clusters is returned. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If no value is provided, the default value is 1% of the bounding box diagonal. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_attraction_factor">attraction_factor</a></td><td>used to compute adjacencies between clusters. Adjacencies are computed using a nearest neighbor graph built similarly to the one used for clustering, using <code>attraction_factor * neighbor_radius</code> as parameter. Default value is <code>2</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_adjacencies">adjacencies</a></td><td>model of <code>OutputIterator</code> that accepts objects of type <code>std::pair&lt;std::size_t, std::size_t&gt;</code>. Each pair contains the indices of two adjacent clusters. If this parameter is not used, adjacencies are not computed at all. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of clusters identified. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2clustering_example_8cpp-example.html#a2">Point_set_processing_3/clustering_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaa74cb0739e0d74f495d3a65e7e1b4e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa74cb0739e0d74f495d3a65e7e1b4e7e">&#9670;&nbsp;</a></span>compute_average_spacing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename CGAL_BGL_NP_TEMPLATE_PARAMETERS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FT CGAL::compute_average_spacing </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL_BGL_NP_CLASS &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/compute_average_spacing.h&gt;</code></p>
<p>Computes average spacing from k nearest neighbors.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>k &gt;= 2.</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and the average spacing value estimated on the processed subset is returned. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>average spacing (scalar). The return type <code>FT</code> is a number type. It is either deduced from the <code>geom_traits</code> <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> if provided, or the geometric traits class deduced from the point property map of <code>points</code>. </dd></dl>

</div>
</div>
<a id="gab81663c718960780ddb176aad845e8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab81663c718960780ddb176aad845e8cd">&#9670;&nbsp;</a></span>compute_registration_transformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;geom_traits::Aff_transformation_3, double&gt; CGAL::OpenGR::compute_registration_transformation </td>
          <td>(</td>
          <td class="paramtype">const PointRange1 &amp;&#160;</td>
          <td class="paramname"><em>point_set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointRange2 &amp;&#160;</td>
          <td class="paramname"><em>point_set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters1 &amp;&#160;</td>
          <td class="paramname"><em>np1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters2 &amp;&#160;</td>
          <td class="paramname"><em>np2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</code></p>
<p>Computes the registration of <code>point_set_2</code> with respect to <code>point_set_1</code> and returns the corresponding affine transformation along with the registration score.</p>
<p>Registration is computed using the Super4PCS algorithm <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[10]</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires the thirdpartyOpenGR library.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Although this may seem counter-intuitive, if one of the two point set matches only a small section of the other one, it is advised to <em>use the small point set as reference</em> instead of the big one. The reason is that the reference point set is used to construct a base that is sought after in the other point set: if the big point set is used as reference, chances are the constructed base will not be present in the small point set.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange1</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters1</code>. </td></tr>
    <tr><td class="paramname">PointRange2</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_set_1</td><td>input point range used as reference. </td></tr>
    <tr><td class="paramname">point_set_2</td><td>input point range whose registration w.r.t. <code>point_set_1</code> will be computed. </td></tr>
    <tr><td class="paramname">np1</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td><p class="starttd">a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type <code>geom_traits::Vector_3</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_number_of_samples">number_of_samples</a></td><td><p class="starttd">size of the subset of input points used to compute registration. Input clouds are sub-sampled prior exploration, to ensure fast computations. Super4PCS has a linear complexity w.r.t. the number of input samples, allowing to use larger values than 4PCS. Simple geometry with large overlap can be matched with only 200 samples. However, with Super4PCS, smaller details can be used during the process by using up to thousands of points. There is no theoretical limit to this parameter, however using too large values leads to very a large congruent set, which requires more time and memory to be explored. Using a large number of samples is recommended when: geometrical details are required to perform the matching, for instance to disambiguate between several similar configurations; the clouds have a very low overlap: using a too sparse sampling can prevent to have samples in the overlapping area, causing the algorithm to fail; the clouds are very noisy, and require a dense sampling. Note that Super4PCS is a global registration algorithm, which finds a good approximate of the rigid transformation aligning too clouds. Increasing the number of samples in order to get a fine registration is not optimal: it is usually faster to use less samples, and refine the transformation using a local algorithm, like the ICP, or its variant SparseICP.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_maximum_normal_deviation">maximum_normal_deviation</a></td><td><p class="starttd">angle threshold (in degrees) used to filter pairs of points according to their normal consistency. Small values decrease computation time but may also decrease the quality if pairs of points that should match have a normal deviation higher than the threshold.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_accuracy">accuracy</a></td><td><p class="starttd">registration accuracy (delta in the paper). Setting a small value means that the two clouds needs to be very close to be considered as well aligned. It is expressed in scene units. A simple way to understand its impact is to consider the computation of the Largest Common Pointset (LCP), the metric used to verify how much the clouds are aligned. For each transformation matrix produced by Super4PCS, we compute the LCP measure by considering a shell around the reference cloud, and count the percentage of points of the target cloud lying in the shell. The thickness of the shell is defined by the parameter delta.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_overlap">overlap</a></td><td><p class="starttd">ratio of expected overlap between the two point sets: it is ranging between 0 (no overlap) to 1 (100% overlap). The overlap parameter controls the size of the basis used for registration. Usually, the larger the overlap, the faster the algorithm. When the overlap is unknown, a simple way to set this parameter is to start from 100% overlap, and decrease the value until obtaining a good result. Using too small values will slow down the algorithm, and reduce the accuracy of the result.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_maximum_running_time">maximum_running_time</a></td><td><p class="starttd">maximum number of seconds after which the algorithm stops. Super4PCS explores the transformation space to align the two input clouds. Since the exploration is performed randomly, it is recommended to use a large time value to explore the whole space. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">np2</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type <code>geom_traits::Vector_3</code>. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the affine transformation that should be applied to <code>point_set_2</code> to make it registered w.r.t. <code>point_set_1</code> and the registration score. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2registration_with_OpenGR_8cpp-example.html#a4">Point_set_processing_3/registration_with_OpenGR.cpp</a>, and <a class="el" href="Point_set_processing_3_2registration_with_opengr_pointmatcher_pipeline_8cpp-example.html#a4">Point_set_processing_3/registration_with_opengr_pointmatcher_pipeline.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaf75af5c1634fa83fa05a33e95570b127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf75af5c1634fa83fa05a33e95570b127">&#9670;&nbsp;</a></span>compute_registration_transformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;geom_traits::Aff_transformation_3, bool&gt; CGAL::pointmatcher::compute_registration_transformation </td>
          <td>(</td>
          <td class="paramtype">const PointRange1 &amp;&#160;</td>
          <td class="paramname"><em>point_set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointRange2 &amp;&#160;</td>
          <td class="paramname"><em>point_set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters1 &amp;&#160;</td>
          <td class="paramname"><em>np1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters2 &amp;&#160;</td>
          <td class="paramname"><em>np2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/pointmatcher/compute_registration_transformation.h&gt;</code></p>
<p>Computes the registration of <code>point_set_2</code> with respect to <code>point_set_1</code> and returns the corresponding affine transformation. Registration is computed using the Iterative Closest Point (ICP) algorithm. </p><dl class="section note"><dt>Note</dt><dd>This function requires the thirdpartylibpointmatcher library. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange1</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters1</code>. </td></tr>
    <tr><td class="paramname">PointRange2</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_set_1</td><td>input point range used as reference. </td></tr>
    <tr><td class="paramname">point_set_2</td><td>input point range whose registration w.r.t. <code>point_set_1</code> will be computed. </td></tr>
    <tr><td class="paramname">np1</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below. <dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td><p class="starttd">a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type <code>geom_traits::Vector_3</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_set_filters">point_set_filters</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>.</p>
<p class="intertd">The chain of filters to be applied to the reference point cloud. The reference point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p class="intertd">The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of the ICP algorithm.</p>
<p class="intertd">The filters can have several purposes, including but are not limited to i) removal of noisy points which render alignment of point clouds difficult, ii) removal of redundant points so as to speed up alignment, iii) addition of descriptive information to the points such as a surface normal vector, or the direction from the point to the sensor.</p>
<p class="intertd">Corresponds to <code>referenceDataPointsFilters</code> configuration module of thirdpartylibpointmatcher library. The filters should be chosen and set from possible components of the <code>referenceDataPointsFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>RandomSamplingDataPointsFilter</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_matcher">matcher</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The method used for matching (linking) the points from <code>point_set_2</code>, to the points in the reference cloud, <code>point_set_1</code>.</p>
<p class="intertd">Corresponds to <code>matcher</code> configuration module of thirdpartylibpointmatcher library. The matcher should be chosen and set from possible components of the <code>matcher</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>KDTreeMatcher</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_outlier_filters">outlier_filters</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The chain of filters to be applied to the matched (linked) point clouds after each processing iteration of the ICP algorithm to remove the links which do not correspond to true point correspondences. The outliers are rejected. Points with no link are ignored in the subsequent error minimization step. The chain is organized with the forward traversal order of the outlier filters range.</p>
<p class="intertd">Corresponds to <code>outlierFilters</code> configuration module of thirdpartylibpointmatcher library. The filters should be chosen and set from possible components of the <code>outlierFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>TrimmedDistOutlierFilter</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_error_minimizer">error_minimizer</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The error minimizer that computes a transformation matrix such as to minimize the error between the point sets.</p>
<p class="intertd">Corresponds to <code>errorMinimizer</code> configuration module of thirdpartylibpointmatcher library. The error minimizer should be chosen and set from possible components of the <code>errorMinimizer</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>PointToPlaneErrorMinimizer</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_transformation_checkers">transformation_checkers</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The chain of transformation checkers. A transformation checker can stop the iteration depending on the conditions it defines.</p>
<p class="intertd">The chain is organized with the forward traversal order of the transformation checkers range.</p>
<p class="intertd">Corresponds to <code>transformationCheckers</code> configuration module of thirdpartylibpointmatcher library. The transformation checkers should be chosen and set from possible components of the <code>transformationCheckers</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, the chain of <code>CounterTransformationChecker</code> and <code>DifferentialTransformationChecker</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_inspector">inspector</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The inspector allows to log data at different steps for analysis. Inspectors typically provide deeper scrutiny than the logger.</p>
<p class="intertd">Corresponds to <code>inspector</code> configuration module of thirdpartylibpointmatcher library. The inspector should be chosen and set from possible components of the <code>inspector</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>NullInspector</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_logger">logger</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The method for logging information regarding the registration process outputted by thirdpartylibpointmatcher library. The logs generated by <a class="el" href="namespaceCGAL.html">CGAL</a> library does not get effected by this configuration.</p>
<p class="intertd">Corresponds to <code>logger</code> configuration module of thirdpartylibpointmatcher library. The logger should be chosen and set from possible components of the <code>logger</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>NullLogger</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td><p class="starttd">an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code></p>
<p class="endtd"></p>
</td></tr>
</table>
</dd>
</dl>
</td></tr>
    <tr><td class="paramname">np2</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below. <dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td><p class="starttd">a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type <code>geom_traits::Vector_3</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_set_filters">point_set_filters</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>.</p>
<p class="intertd">The chain of filters to be applied to the point cloud, <code>point_set_2</code>. The point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p class="intertd">The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of ICP algorithm.</p>
<p class="intertd">The filters can have several purposes, including but are not limited to i) removal of noisy points which render alignment of point clouds difficult, ii) removal of redundant points so as to speed up alignment, iii) addition of descriptive information to the points such as a surface normal vector, or the direction from the point to the sensor.</p>
<p class="intertd">Corresponds to <code>readingDataPointsFilters</code> configuration module of thirdpartylibpointmatcher library. The filters should be chosen and set from possible components of the <code>readingDataPointsFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>SamplingSurfaceNormalDataPointsFilter</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_transformation">transformation</a></td><td><p class="starttd">The affine transformation that is used as the initial transformation for <code>point_set_2</code>.</p>
<p class="intertd">If this parameter is omitted, identity transformation is used. </p>
<p class="endtd"></p>
</td></tr>
</table>
</dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the affine transformation that should be applied to <code>point_set_2</code> to make it registered w.r.t. <code>point_set_1</code> and the boolean value indicating if the registration converged. The second of the pair is <code>true</code> if converged, <code>false</code> otherwise. A log why it failed to converge is written to <code>std::cerr</code> if the registration cannot converge. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2registration_with_pointmatcher_8cpp-example.html#a6">Point_set_processing_3/registration_with_pointmatcher.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga1e6e7a9531de6f6a1746fbc78cc2f47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6e7a9531de6f6a1746fbc78cc2f47a">&#9670;&nbsp;</a></span>compute_registration_transformations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange , class CorrespondencesRange , class NamedParameters , class TransformRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::OpenGR::compute_registration_transformations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointRange &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_clouds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CorrespondencesRange &amp;&#160;</td>
          <td class="paramname"><em>correspondences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_global_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformRange &amp;&#160;</td>
          <td class="paramname"><em>transformations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/OpenGR/gret_sdp.h&gt;</code></p>
<p>Computes the registration of the point clouds in <code>point_clouds</code> using the correspondences provided in <code>correspondences</code> and stores the respective affine transformations in <code>transformations</code>.</p>
<p>Registration is computed using the GRET-SDP algorithm that is described in <a class="el" href="citelist.html#CITEREF_cgal:cks-grmpcsp">[2]</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires the thirdpartyOpenGR library.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters</code>. </td></tr>
    <tr><td class="paramname">CorrespondencesRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is std::tuple&lt;size_t, size_t, size_t&gt;. </td></tr>
    <tr><td class="paramname">TransformRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code> whose size is the number of point clouds. The value type of its iterator is <code>geom_traits::Aff_transformation_3</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_clouds</td><td>vector of input point ranges of the point clouds to be registered. </td></tr>
    <tr><td class="paramname">correspondences</td><td>input range of correspondences. Correspondences are represented using tuples of three indexes (in order): point cloud index, point index, global coordinate index. The first two indexes with respect to <code>point_clouds</code>. <br  />
 </td></tr>
    <tr><td class="paramname">num_global_coordinates</td><td>number of global coordinates. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below. </td></tr>
    <tr><td class="paramname">transformations</td><td>ouput range of the affine transformations where the i'th transformation should be applied to the i'th point cloud in order to register them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange</code> and whose value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2registration_with_OpenGR_using_GRET_SDP_8cpp-example.html#a10">Point_set_processing_3/registration_with_OpenGR_using_GRET_SDP.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga4090777b535d58b5acf30ab7fb7cf488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4090777b535d58b5acf30ab7fb7cf488">&#9670;&nbsp;</a></span>compute_vcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::compute_vcm </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; double, 6 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ccov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>convolution_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/vcm_estimate_normals.h&gt;</code></p>
<p>computes the Voronoi Covariance Measure (VCM) of a point cloud, a construction that can be used for normal estimation and sharp feature detection.</p>
<p>The VCM associates to each point the covariance matrix of its Voronoi cell intersected with the ball of radius <code>offset_radius</code>. In addition, if the second radius <code>convolution_radius</code> is positive, the covariance matrices are smoothed via a convolution process. More specifically, each covariance matrix is replaced by the average of the matrices of the points located at a distance at most <code>convolution_radius</code>. The choice for parameter <code>offset_radius</code> should refer to the geometry of the underlying surface while the choice for parameter <code>convolution_radius</code> should refer to the noise level in the point cloud. For example, if the point cloud is a uniform and noise-free sampling of a smooth surface, <code>offset_radius</code> should be set to the minimum local feature size of the surface, while <code>convolution_radius</code> can be set to zero.</p>
<p>The Voronoi covariance matrix of each vertex is stored in an array <code>a</code> of length 6 and is as follow:</p>
<center> \( \begin{bmatrix} a[0] &amp; a[1] &amp; a[2] \\ a[1] &amp; a[3] &amp; a[4] \\ a[2] &amp; a[4] &amp; a[5] \\ \end{bmatrix}\) </center><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">ccov</td><td>output range of covariance matrices. </td></tr>
    <tr><td class="paramname">offset_radius</td><td>offset_radius. </td></tr>
    <tr><td class="paramname">convolution_radius</td><td>convolution_radius. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e">CGAL::vcm_is_on_feature_edge()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga020a2ee77849fc70cbbee93358222dff">CGAL::vcm_estimate_normals()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2edges_example_8cpp-example.html#a5">Point_set_processing_3/edges_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga128b4cd2445490a0f1c3f573216ac477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga128b4cd2445490a0f1c3f573216ac477">&#9670;&nbsp;</a></span>edge_aware_upsample_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename OutputIterator , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::edge_aware_upsample_point_set </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/edge_aware_upsample_point_set.h&gt;</code></p>
<p>This method progressively upsamples the point set while approaching the edge singularities (detected by normal variation), which generates a denser point set from an input point set. This has applications in point-based rendering, hole filling, and sparse surface reconstruction. Normals of points are required as input. For more details, please refer to <a class="el" href="citelist.html#CITEREF_ear-2013">[6]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel versions of <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa74cb0739e0d74f495d3a65e7e1b4e7e">compute_average_spacing()</a></code> (called internally). Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Type of the output iterator. The type of the objects put in it is <code>std::pair&lt;geom_traits::Point_3, geom_traits::Vector_3&gt;</code>. Note that the user may use a <a href="https://www.boost.org/libs/iterator/doc/function_output_iterator.html">function_output_iterator</a> to match specific needs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">output</td><td>iterator where output points and normals are put. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_sharpness_angle">sharpness_angle</a></td><td>controls the sharpness of the result. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_edge_sensitivity">edge_sensitivity</a></td><td>controls the priority of points inserted along sharp features. See section <a class="el" href="index.html#Point_set_processing_3Upsample_Parameter1">Parameter: edge_sensitivity</a> for an example. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_number_of_output_points">number_of_output_points</a></td><td>is the number of output points to generate. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga7a0e851fd41f7ea2c640eff9f5a3fc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0e851fd41f7ea2c640eff9f5a3fc2b">&#9670;&nbsp;</a></span>estimate_global_k_neighbor_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::estimate_global_k_neighbor_scale </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/estimate_scale.h&gt;</code></p>
<p>Estimates the global scale in a K nearest neighbors sense. The computed scale corresponds to the smallest scale such that the K subsets of points have the appearance of a surface in 3D or the appearance of a curve in 2D (see <a class="el" href="index.html#Point_set_processing_3Scale">Automatic Scale Estimation</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code> (or <code>geom_traits::Point_2</code>). If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> (or <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_2&gt;</code>) is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function accepts both 2D and 3D points.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated scale in the K nearest neighbors sense. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html#a4">Point_set_processing_3/scale_estimation_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga8b8e7e8e694d746cfa0bca11f87fb527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8e7e8e694d746cfa0bca11f87fb527">&#9670;&nbsp;</a></span>estimate_global_range_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FT CGAL::estimate_global_range_scale </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/estimate_scale.h&gt;</code></p>
<p>Estimates the global scale in a range sense. The computed scale corresponds to the smallest scale such that the subsets of points inside the sphere range have the appearance of a surface in 3D or the appearance of a curve in 2D (see <a class="el" href="index.html#Point_set_processing_3Scale">Automatic Scale Estimation</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code> (or <code>geom_traits::Point_2</code>). If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> (or <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_2&gt;</code>) is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function accepts both 2D and 3D points.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated scale in the range sense. The return type <code>FT</code> is a number type. It is either deduced from the <code>geom_traits</code> <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> if provided, or the geometric traits class deduced from the point property map of <code>points</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html#a5">Point_set_processing_3/scale_estimation_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gab8b8b073db1b79e1cc482114044fd76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b8b073db1b79e1cc482114044fd76c">&#9670;&nbsp;</a></span>estimate_local_k_neighbor_scales()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename QueryPointRange , typename OutputIterator , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::estimate_local_k_neighbor_scales </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryPointRange &amp;&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/estimate_scale.h&gt;</code></p>
<p>Estimates the local scale in a K nearest neighbors sense on a set of user-defined query points. The computed scales correspond to the smallest scales such that the K subsets of points have the appearance of a surface in 3D or the appearance of a curve in 2D (see <a class="el" href="index.html#Point_set_processing_3Scale">Automatic Scale Estimation</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>. </td></tr>
    <tr><td class="paramname">QueryPointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>query_point_map</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is used to store the computed scales. It accepts values of type <code>std::size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">queries</td><td>range of locations where scale must be estimated </td></tr>
    <tr><td class="paramname">output</td><td>iterator to store the computed scales </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code> (or <code>geom_traits::Point_2</code>). If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> (or <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_2&gt;</code>) is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_query_point_map">query_point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code> (or <code>geom_traits::Point_2</code>). If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> (or <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_2&gt;</code>) is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function accepts both 2D and 3D points, but sample points and query must have the same dimension. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2scale_estimation_2d_example_8cpp-example.html#a2">Point_set_processing_3/scale_estimation_2d_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gacc9353050636f6c746585639a282a7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9353050636f6c746585639a282a7b8">&#9670;&nbsp;</a></span>estimate_local_range_scales()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename QueryPointRange , typename OutputIterator , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::estimate_local_range_scales </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueryPointRange &amp;&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/estimate_scale.h&gt;</code></p>
<p>Estimates the local scale in a range sense on a set of user-defined query points. The computed scales correspond to the smallest scales such that the subsets of points included in the sphere range have the appearance of a surface in 3D or the appearance of a curve in 2D (see <a class="el" href="index.html#Point_set_processing_3Scale">Automatic Scale Estimation</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>. </td></tr>
    <tr><td class="paramname">QueryPointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>query_point_map</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is used to store the computed scales. It accepts values of type <code>geom_traits::FT</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">queries</td><td>range of locations where scale must be estimated </td></tr>
    <tr><td class="paramname">output</td><td>iterator to store the computed scales </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code> (or <code>geom_traits::Point_2</code>). If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> (or <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_2&gt;</code>) is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_query_point_map">query_point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code> (or <code>geom_traits::Point_2</code>). If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> (or <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_2&gt;</code>) is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function accepts both 2D and 3D points, but sample points and query must have the same dimension. </dd></dl>

</div>
</div>
<a id="gac7c81cc8a2986e3972e86612e4f847a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c81cc8a2986e3972e86612e4f847a1">&#9670;&nbsp;</a></span>grid_simplify_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointRange::iterator CGAL::grid_simplify_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/grid_simplify_point_set.h&gt;</code></p>
<p>Merges points which belong to the same cell of a grid of cell size = <code>epsilon</code>.</p>
<p>This method modifies the order of input points so as to pack all remaining points first, and returns an iterator over the first point to remove (see erase-remove idiom). For this reason it should not be called on sorted containers.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>epsilon &gt; 0</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">epsilon</td><td>tolerance value when merging 3D points. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and simplification stops with no guarantee on the output. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator over the first point to remove. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2callback_example_8cpp-example.html#a4">Point_set_processing_3/callback_example.cpp</a>, <a class="el" href="Point_set_processing_3_2grid_simplification_example_8cpp-example.html#a3">Point_set_processing_3/grid_simplification_example.cpp</a>, <a class="el" href="Point_set_processing_3_2grid_simplify_indices_8cpp-example.html#a3">Point_set_processing_3/grid_simplify_indices.cpp</a>, and <a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html#a6">Point_set_processing_3/scale_estimation_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga149ceecc075a180669bde3e65742fdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149ceecc075a180669bde3e65742fdf5">&#9670;&nbsp;</a></span>hierarchy_simplify_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointRange::iterator CGAL::hierarchy_simplify_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/hierarchy_simplify_point_set.h&gt;</code></p>
<p>Recursively split the point set in smaller clusters until the clusters have less than <code>size</code> elements and until their variation factor is below <code>var_max</code>.</p>
<p>This method modifies the order of input points so as to pack all remaining points first, and returns an iterator over the first point to remove (see erase-remove idiom). For this reason it should not be called on sorted containers.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>0 &lt; maximum_variation &lt; 1/3</code> </dd>
<dd>
<code>size &gt; 0</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_size">size</a></td><td>maximum cluster size. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_maximum_variation">maximum_variation</a></td><td>maximum cluster variation value. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_diagonalize_traits">diagonalize_traits</a></td><td>a model of <code><a class="elRef" href="../Solver_interface/classDiagonalizeTraits.html">DiagonalizeTraits</a></code>. It can be omitted: if Eigen 3 (or greater) is available and <code>CGAL_EIGEN3_ENABLED</code> is defined then an overload using <code><a class="elRef" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">Eigen_diagonalize_traits</a></code> is provided. Otherwise, the internal implementation <code>CGAL::Diagonalize_traits</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and simplification stops with no guarantee on the output. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator over the first point to remove. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2hierarchy_simplification_example_8cpp-example.html#a3">Point_set_processing_3/hierarchy_simplification_example.cpp</a>, and <a class="el" href="Point_set_processing_3_2registration_with_OpenGR_using_GRET_SDP_8cpp-example.html#a9">Point_set_processing_3/registration_with_OpenGR_using_GRET_SDP.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga0cd0f87de690d4edf82740e856efa491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd0f87de690d4edf82740e856efa491">&#9670;&nbsp;</a></span>jet_estimate_normals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::jet_estimate_normals </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/jet_estimate_normals.h&gt;</code></p>
<p>Estimates normal directions of the range of <code>points</code> using jet fitting on the nearest neighbors. The output normals are randomly oriented.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>k &gt;= 2</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If provided, the neighborhood of a query point is computed with a fixed spherical radius instead of a fixed number of neighbors. In that case, the parameter <code>k</code> is used as a limit on the number of points returned by each spherical query (to avoid overly large number of points in high density areas). If no limit is wanted, use <code>k=0</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_degree_fitting">degree_fitting</a></td><td>degree of jet fitting. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_svd_traits">svd_traits</a></td><td>template parameter for the class <code><a class="elRef" href="../Jet_fitting_3/classCGAL_1_1Monge__via__jet__fitting.html">Monge_via_jet_fitting</a></code>. If Eigen 3.2 (or greater) is available and <code>CGAL_EIGEN3_ENABLED</code> is defined, then <code><a class="elRef" href="../Solver_interface/classCGAL_1_1Eigen__svd.html">CGAL::Eigen_svd</a></code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and the remaining normals are left unchanged. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga549402c0a8a8b6b71875181e93961521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga549402c0a8a8b6b71875181e93961521">&#9670;&nbsp;</a></span>jet_smooth_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::jet_smooth_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/jet_smooth_point_set.h&gt;</code></p>
<p>Smoothes the range of <code>points</code> using jet fitting on the nearest neighbors and reprojection onto the jet. As this method relocates the points, it should not be called on containers sorted w.r.t. point locations.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>k &gt;= 2</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If provided, the neighborhood of a query point is computed with a fixed spherical radius instead of a fixed number of neighbors. In that case, the parameter <code>k</code> is used as a limit on the number of points returned by each spherical query (to avoid overly large number of points in high density areas). If no limit is wanted, use <code>k=0</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_degree_fitting">degree_fitting</a></td><td>degree of jet fitting. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_degree_monge">degree_monge</a></td><td>Monge degree. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_svd_traits">svd_traits</a></td><td>template parameter for the class <code><a class="elRef" href="../Jet_fitting_3/classCGAL_1_1Monge__via__jet__fitting.html">Monge_via_jet_fitting</a></code>. If Eigen 3.2 (or greater) is available and <code>CGAL_EIGEN3_ENABLED</code> is defined, then <code><a class="elRef" href="../Solver_interface/classCGAL_1_1Eigen__svd.html">CGAL::Eigen_svd</a></code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and the remaining points are left unchanged. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga50c98d5c5ae5535bce6f32eddbd03f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50c98d5c5ae5535bce6f32eddbd03f33">&#9670;&nbsp;</a></span>mst_orient_normals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointRange::iterator CGAL::mst_orient_normals </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/mst_orient_normals.h&gt;</code></p>
<p>Orients the normals of the range of <code>points</code> using the propagation of a seed orientation through a minimum spanning tree of the Riemannian graph. This method modifies the order of input points so as to pack all sucessfully oriented points first, and returns an iterator over the first point with an unoriented normal (see erase-remove idiom). For this reason it should not be called on sorted containers. It is based on <a class="el" href="citelist.html#CITEREF_cgal:hddms-srup-92">[4]</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function may fail when Boost version 1.54 is used, because of the following bug: <a href="https://svn.boost.org/trac/boost/ticket/9012">https://svn.boost.org/trac/boost/ticket/9012</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Normals must be unit vectors </dd>
<dd>
<code>k &gt;= 2</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If provided, the neighborhood of a query point is computed with a fixed spherical radius instead of a fixed number of neighbors. In that case, the parameter <code>k</code> is used as a limit on the number of points returned by each spherical query (to avoid overly large number of points in high density areas). If no limit is wanted, use <code>k=0</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_is_constrained_map">point_is_constrained_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>bool</code>. Points with a <code>true</code> value will be used as seed points: their normal will be considered as already oriented, it won't be altered and it will be propagated to its neighbors. If this parameter is omitted, the highest point (highest Z coordinate) will be used as the unique seed with an upward oriented normal </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator over the first point with an unoriented normal. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2normals_example_8cpp-example.html#a7">Point_set_processing_3/normals_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga8c642da96a025ab32445aeb6cc219b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c642da96a025ab32445aeb6cc219b0b">&#9670;&nbsp;</a></span>pca_estimate_normals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::pca_estimate_normals </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/pca_estimate_normals.h&gt;</code></p>
<p>Estimates normal directions of the range of <code>points</code> by linear least squares fitting of a plane over the nearest neighbors. The output normals are randomly oriented.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>k &gt;= 2</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>WritablePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If provided, the neighborhood of a query point is computed with a fixed spherical radius instead of a fixed number of neighbors. In that case, the parameter <code>k</code> is used as a limit on the number of points returned by each spherical query (to avoid overly large number of points in high density areas). If no limit is wanted, use <code>k=0</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped and the remaining normals are left unchanged. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga4be2d94f1791d24b8ba0107bc33ad6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4be2d94f1791d24b8ba0107bc33ad6dc">&#9670;&nbsp;</a></span>random_simplify_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointRange::iterator CGAL::random_simplify_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>removed_percentage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/random_simplify_point_set.h&gt;</code></p>
<p>Randomly deletes a user-specified fraction of the input points.</p>
<p>This method modifies the order of input points so as to pack all remaining points first, and returns an iterator over the first point to remove (see erase-remove idiom). For this reason it should not be called on sorted containers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">removed_percentage</td><td>percentage of points to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator over the first point to remove. </dd></dl>

</div>
</div>
<a id="gae9ed21b37f02e0f36497c69f687b2fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ed21b37f02e0f36497c69f687b2fad">&#9670;&nbsp;</a></span>register_point_clouds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange , class CorrespondencesRange , class NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::OpenGR::register_point_clouds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PointRange &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_clouds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CorrespondencesRange &amp;&#160;</td>
          <td class="paramname"><em>correspondences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_global_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>registered_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/OpenGR/gret_sdp.h&gt;</code></p>
<p>Computes the registration of the point clouds in <code>point_clouds</code> using the correspondences provided in <code>correspondences</code> and stores the registered point cloud in <code>registered_points</code>.</p>
<p>Registration is computed using the GRET-SDP algorithm that is described in <a class="el" href="citelist.html#CITEREF_cgal:cks-grmpcsp">[2]</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires the thirdpartyOpenGR library.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters</code>. </td></tr>
    <tr><td class="paramname">CorrespondencesRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is std::tuple&lt;size_t, size_t, size_t&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_clouds</td><td>vector of input point ranges of the point clouds to be registered. </td></tr>
    <tr><td class="paramname">correspondences</td><td>input range of correspondences. Correspondences are represented using tuples of three indexes (in order): point cloud index, point index, global coordinate index. The first two indexes with respect to <code>point_clouds</code>. <br  />
 </td></tr>
    <tr><td class="paramname">num_global_coordinates</td><td>number of global coordinates. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below. </td></tr>
    <tr><td class="paramname">registered_points</td><td>ouput point range of the registered point clouds whose size is the accumulated size of all point clouds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange</code> and whose value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2registration_with_OpenGR_using_GRET_SDP_8cpp-example.html#a11">Point_set_processing_3/registration_with_OpenGR_using_GRET_SDP.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga6194087f512e4e23dd945a9364d0931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6194087f512e4e23dd945a9364d0931d">&#9670;&nbsp;</a></span>register_point_sets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double CGAL::OpenGR::register_point_sets </td>
          <td>(</td>
          <td class="paramtype">const PointRange1 &amp;&#160;</td>
          <td class="paramname"><em>point_set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointRange2 &amp;&#160;</td>
          <td class="paramname"><em>point_set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters1 &amp;&#160;</td>
          <td class="paramname"><em>np1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters2 &amp;&#160;</td>
          <td class="paramname"><em>np2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/OpenGR/register_point_sets.h&gt;</code></p>
<p>Computes the registration of <code>point_set_2</code> with respect to <code>point_set_1</code> and applies it.</p>
<p>Registration is computed using the Super4PCS algorithm <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[10]</a>. Parameters documentation is copy-pasted from <a href="https://storm-irit.github.io/OpenGR/a00012.html">the official documentation of OpenGR</a>. For more details on this method, please refer to it.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires the thirdpartyOpenGR library.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Although this may seem counter-intuitive, if one of the two point set matches only a small section of the other one, it is advised to <em>use the small point set as reference</em> instead of the big one. The reason is that the reference point set is used to construct a base that is sought after in the other point set: if the big point set is used as reference, chances are the constructed base will not be present in the small point set.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange1</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters1</code>. </td></tr>
    <tr><td class="paramname">PointRange2</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_set_1</td><td>input point range used as reference. </td></tr>
    <tr><td class="paramname">point_set_2</td><td>input point range whose registration w.r.t. <code>point_set_1</code> will be computed. </td></tr>
    <tr><td class="paramname">np1</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td><p class="starttd">a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type <code>geom_traits::Vector_3</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_number_of_samples">number_of_samples</a></td><td><p class="starttd">size of the subset of input points used to compute registration. Input clouds are sub-sampled prior exploration, to ensure fast computations. Super4PCS has a linear complexity w.r.t. the number of input samples, allowing to use larger values than 4PCS. Simple geometry with large overlap can be matched with only 200 samples. However, with Super4PCS, smaller details can be used during the process by using up to thousands of points. There is no theoretical limit to this parameter, however using too large values leads to very a large congruent set, which requires more time and memory to be explored. Using a large number of samples is recommended when: geometrical details are required to perform the matching, for instance to disambiguate between several similar configurations; the clouds have a very low overlap: using a too sparse sampling can prevent to have samples in the overlapping area, causing the algorithm to fail; the clouds are very noisy, and require a dense sampling. Note that Super4PCS is a global registration algorithm, which finds a good approximate of the rigid transformation aligning too clouds. Increasing the number of samples in order to get a fine registration is not optimal: it is usually faster to use less samples, and refine the transformation using a local algorithm, like the ICP, or its variant SparseICP.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_accuracy">accuracy</a></td><td><p class="starttd">registration accuracy (delta in the paper). Setting a small value means that the two clouds needs to be very close to be considered as well aligned. It is expressed in scene units. A simple way to understand its impact is to consider the computation of the Largest Common Pointset (LCP), the metric used to verify how much the clouds are aligned. For each transformation matrix produced by Super4PCS, we compute the LCP measure by considering a shell around the reference cloud, and count the percentage of points of the target cloud lying in the shell. The thickness of the shell is defined by the parameter delta.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_maximum_normal_deviation">maximum_normal_deviation</a></td><td><p class="starttd">angle threshold (in degrees) used to filter pairs of points according to their normal consistency. Small values decrease computation time but may also decrease the quality if pairs of points that should match have a normal deviation higher than the threshold.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_overlap">overlap</a></td><td><p class="starttd">ratio of expected overlap between the two point sets: it is ranging between 0 (no overlap) to 1 (100% overlap). The overlap parameter controls the size of the basis used for registration. Usually, the larger the overlap, the faster the algorithm. When the overlap is unknown, a simple way to set this parameter is to start from 100% overlap, and decrease the value until obtaining a good result. Using too small values will slow down the algorithm, and reduce the accuracy of the result.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_maximum_running_time">maximum_running_time</a></td><td><p class="starttd">maximum number of seconds after which the algorithm stops. Super4PCS explores the transformation space to align the two input clouds. Since the exploration is performed randomly, it is recommended to use a large time value to explore the whole space. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">np2</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type <code>geom_traits::Vector_3</code>. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the registration score. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2registration_with_OpenGR_8cpp-example.html#a5">Point_set_processing_3/registration_with_OpenGR.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaa222278e20a3ce41930d37326cd54ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa222278e20a3ce41930d37326cd54ef9">&#9670;&nbsp;</a></span>register_point_sets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointRange1 , class PointRange2 , class NamedParameters1 , class NamedParameters2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::pointmatcher::register_point_sets </td>
          <td>(</td>
          <td class="paramtype">const PointRange1 &amp;&#160;</td>
          <td class="paramname"><em>point_set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointRange2 &amp;&#160;</td>
          <td class="paramname"><em>point_set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters1 &amp;&#160;</td>
          <td class="paramname"><em>np1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters2 &amp;&#160;</td>
          <td class="paramname"><em>np2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</code></p>
<p>Computes the registration of <code>point_set_2</code> with respect to <code>point_set_1</code> and applies it.</p>
<p>Registration is computed using the Iterative Closest Point (ICP) algorithm.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires the thirdpartylibpointmatcher library.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange1</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters1</code>. </td></tr>
    <tr><td class="paramname">PointRange2</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code> in <code>NamedParameters2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_set_1</td><td>input point range used as reference. </td></tr>
    <tr><td class="paramname">point_set_2</td><td>input point range whose registration w.r.t. <code>point_set_1</code> will be computed. </td></tr>
    <tr><td class="paramname">np1</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td><p class="starttd">a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange1</code> and whose value type <code>geom_traits::Vector_3</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_set_filters">point_set_filters</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>.</p>
<p class="intertd">The chain of filters to be applied to the reference point cloud. The reference point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p class="intertd">The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of the ICP algorithm.</p>
<p class="intertd">The filters can have several purposes, including but are not limited to i) removal of noisy points which render alignment of point clouds difficult, ii) removal of redundant points so as to speed up alignment, iii) addition of descriptive information to the points such as a surface normal vector, or the direction from the point to the sensor.</p>
<p class="intertd">Corresponds to <code>referenceDataPointsFilters</code> configuration module of thirdpartylibpointmatcher library. The filters should be chosen and set from possible components of the <code>referenceDataPointsFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>RandomSamplingDataPointsFilter</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_matcher">matcher</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The method used for matching (linking) the points from <code>point_set_2</code>, to the points in the reference cloud, <code>point_set_1</code>.</p>
<p class="intertd">Corresponds to <code>matcher</code> configuration module of thirdpartylibpointmatcher library. The matcher should be chosen and set from possible components of the <code>matcher</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>KDTreeMatcher</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_outlier_filters">outlier_filters</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The chain of filters to be applied to the matched (linked) point clouds after each processing iteration of the ICP algorithm to remove the links which do not correspond to true point correspondences. The outliers are rejected. Points with no link are ignored in the subsequent error minimization step. The chain is organized with the forward traversal order of the outlier filters range.</p>
<p class="intertd">Corresponds to <code>outlierFilters</code> configuration module of thirdpartylibpointmatcher library. The filters should be chosen and set from possible components of the <code>outlierFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>TrimmedDistOutlierFilter</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_error_minimizer">error_minimizer</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The error minimizer that computes a transformation matrix such as to minimize the error between the point sets.</p>
<p class="intertd">Corresponds to <code>errorMinimizer</code> configuration module of thirdpartylibpointmatcher library. The error minimizer should be chosen and set from possible components of the <code>errorMinimizer</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>PointToPlaneErrorMinimizer</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_transformation_checkers">transformation_checkers</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The chain of transformation checkers. A transformation checker can stop the iteration depending on the conditions it defines.</p>
<p class="intertd">The chain is organized with the forward traversal order of the transformation checkers range.</p>
<p class="intertd">Corresponds to <code>transformationCheckers</code> configuration module of thirdpartylibpointmatcher library. The transformation checkers should be chosen and set from possible components of the <code>transformationCheckers</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, the chain of <code>CounterTransformationChecker</code> and <code>DifferentialTransformationChecker</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_inspector">inspector</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The inspector allows to log data at different steps for analysis. Inspectors typically provide deeper scrutiny than the logger.</p>
<p class="intertd">Corresponds to <code>inspector</code> configuration module of thirdpartylibpointmatcher library. The inspector should be chosen and set from possible components of the <code>inspector</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>NullInspector</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_logger">logger</a></td><td><p class="starttd">is a model of <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>. The method for logging information regarding the registration process outputted by thirdpartylibpointmatcher library. The logs generated by <a class="el" href="namespaceCGAL.html">CGAL</a> library does not get effected by this configuration.</p>
<p class="intertd">Corresponds to <code>logger</code> configuration module of thirdpartylibpointmatcher library. The logger should be chosen and set from possible components of the <code>logger</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>NullLogger</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">np2</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below. <dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type is <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td><p class="starttd">a model of <code>ReadablePropertyMap</code> whose key type is the value type of the iterator of <code>PointRange2</code> and whose value type <code>geom_traits::Vector_3</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_set_filters">point_set_filters</a></td><td><p class="starttd">is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is <code><a class="el" href="structCGAL_1_1pointmatcher_1_1ICP__config.html" title="The class ICP_config is designed to handle preparing and passing configurations to the registration m...">ICP_config</a></code>.</p>
<p class="intertd">The chain of filters to be applied to the point cloud, <code>point_set_2</code>. The point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p class="intertd">The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of ICP algorithm.</p>
<p class="intertd">The filters can have several purposes, including but are not limited to i) removal of noisy points which render alignment of point clouds difficult, ii) removal of redundant points so as to speed up alignment, iii) addition of descriptive information to the points such as a surface normal vector, or the direction from the point to the sensor.</p>
<p class="intertd">Corresponds to <code>readingDataPointsFilters</code> configuration module of thirdpartylibpointmatcher library. The filters should be chosen and set from possible components of the <code>readingDataPointsFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<p class="intertd">If this parameter is omitted, <code>SamplingSurfaceNormalDataPointsFilter</code> is used. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_transformation">transformation</a></td><td><p class="starttd">The affine transformation that is used as the initial transformation for <code>point_set_2</code>.</p>
<p class="intertd">If this parameter is omitted, identity transformation is used. </p>
<p class="endtd"></p>
</td></tr>
</table>
</dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if registration is converged, <code>false</code> otherwise. A log why it failed to converge is written to <code>std::cerr</code> if the registration cannot converge. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2registration_with_opengr_pointmatcher_pipeline_8cpp-example.html#a5">Point_set_processing_3/registration_with_opengr_pointmatcher_pipeline.cpp</a>, and <a class="el" href="Point_set_processing_3_2registration_with_pointmatcher_8cpp-example.html#a7">Point_set_processing_3/registration_with_pointmatcher.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga1ab1dcee59caadde50572c5a504cc41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab1dcee59caadde50572c5a504cc41a">&#9670;&nbsp;</a></span>remove_outliers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointRange::iterator CGAL::remove_outliers </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/remove_outliers.h&gt;</code></p>
<p>Removes outliers:</p><ul>
<li>computes average squared distance to the nearest neighbors,</li>
<li>and partitions the points either using a threshold on the of average distance or selecting a fixed percentage of points with the highest average distances</li>
</ul>
<p>This method modifies the order of input points so as to pack all remaining points first, and returns an iterator over the first point to remove (see erase-remove idiom). For this reason it should not be called on sorted containers.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>k &gt;= 2</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. If provided, the neighborhood of a query point is computed with a fixed spherical radius instead of a fixed number of neighbors. In that case, the parameter <code>k</code> is used as a limit on the number of points returned by each spherical query (to avoid overly large number of points in high density areas). If no limit is wanted, use <code>k=0</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_threshold_percent">threshold_percent</a></td><td>maximum percentage of points to remove. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_threshold_distance">threshold_distance</a></td><td>minimum distance for a point to be considered as outlier (distance here is the square root of the average squared distance to K nearest neighbors). </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped, all points are left unchanged and the function return <code>points.end()</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator over the first point to remove.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are two thresholds that can be used: <code>threshold_percent</code> and <code>threshold_distance</code>. This function returns the smallest number of outliers such that at least one of these threshold is fulfilled. This means that if <code>threshold_percent=100</code>, only <code>threshold_distance</code> is taken into account; if <code>threshold_distance=0</code> only <code>threshold_percent</code> is taken into account. </dd></dl>

</div>
</div>
<a id="gaebbc04909dfd575a94f932c8d3bacdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebbc04909dfd575a94f932c8d3bacdce">&#9670;&nbsp;</a></span>structure_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename PlaneRange , typename OutputIterator , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::structure_point_set </td>
          <td>(</td>
          <td class="paramtype">const PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlaneRange &amp;&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/structure_point_set.h&gt;</code></p>
<p>This is an implementation of the Point Set Structuring algorithm. This algorithm takes advantage of a set of detected planes: it detects adjacency relationships between planes and resamples the detected planes, edges and corners to produce a structured point set.</p>
<p>The size parameter <code>epsilon</code> is used both for detecting adjacencies and for setting the sampling density of the structured point set.</p>
<p>For more details, please refer to <a class="el" href="citelist.html#CITEREF_cgal:la-srpss-13">[8]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>. </td></tr>
    <tr><td class="paramname">PlaneRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classConstRange.html">ConstRange</a></code>. The value type of its iterator is the key type of the named parameter <code>plane_map</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Type of the output iterator. The type of the objects put in it is <code>std::pair&lt;<a class="elRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>, <a class="elRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>&gt;</code>. Note that the user may use a <a href="https://www.boost.org/libs/iterator/doc/function_output_iterator.html">function_output_iterator</a> to match specific needs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">planes</td><td>input plane range. </td></tr>
    <tr><td class="paramname">output</td><td>output iterator where output points are written </td></tr>
    <tr><td class="paramname">epsilon</td><td>size parameter. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_plane_index_map">plane_index_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>int</code>. Associates the index of a point in the input range to the index of plane (-1 if point does is not assigned to a plane). </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_plane_map">plane_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Plane_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Plane_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_attraction_factor">attraction_factor</a></td><td>multiple of <code>epsilon</code> used to connect simplices. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2structuring_example_8cpp-example.html#a8">Point_set_processing_3/structuring_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga020a2ee77849fc70cbbee93358222dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020a2ee77849fc70cbbee93358222dff">&#9670;&nbsp;</a></span>vcm_estimate_normals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::vcm_estimate_normals </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>convolution_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/vcm_estimate_normals.h&gt;</code></p>
<p>Estimates normal directions of the range of <code>points</code> using the Voronoi Covariance Measure with a radius for the convolution. The output normals are randomly oriented.</p>
<p>See <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4090777b535d58b5acf30ab7fb7cf488">compute_vcm()</a></code> for a detailed description of the parameters <code>offset_radius</code> and <code>convolution_radius</code> and of the Voronoi Covariance Measure.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">offset_radius</td><td>offset_radius. </td></tr>
    <tr><td class="paramname">convolution_radius</td><td>convolution_radius. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>WritablePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_diagonalize_traits">diagonalize_traits</a></td><td>a model of <code><a class="elRef" href="../Solver_interface/classDiagonalizeTraits.html">DiagonalizeTraits</a></code>. It can be omitted: if Eigen 3 (or greater) is available and <code>CGAL_EIGEN3_ENABLED</code> is defined then an overload using <code><a class="elRef" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">Eigen_diagonalize_traits</a></code> is provided. Otherwise, the internal implementation <code>CGAL::Diagonalize_traits</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga6c0104e0562c13b009bc698b20f378c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c0104e0562c13b009bc698b20f378c3">&#9670;&nbsp;</a></span>vcm_estimate_normals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointRange , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::vcm_estimate_normals </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/vcm_estimate_normals.h&gt;</code></p>
<p>Estimates normal directions of the range of <code>points</code> using the Voronoi Covariance Measure with a number of neighbors for the convolution. The output normals are randomly oriented.</p>
<p>See <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4090777b535d58b5acf30ab7fb7cf488">compute_vcm()</a></code> for a detailed description of the parameter <code>offset_radius</code> and of the Voronoi Covariance Measure.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">offset_radius</td><td>offset_radius. </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbor points used for convolution. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadablePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>WritablePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_diagonalize_traits">diagonalize_traits</a></td><td>a model of <code><a class="elRef" href="../Solver_interface/classDiagonalizeTraits.html">DiagonalizeTraits</a></code>. It can be omitted: if Eigen 3 (or greater) is available and <code>CGAL_EIGEN3_ENABLED</code> is defined then an overload using <code><a class="elRef" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">Eigen_diagonalize_traits</a></code> is provided. Otherwise, the internal implementation <code>CGAL::Diagonalize_traits</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="gac57ce53e3249a66e4c19e85f439ff01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac57ce53e3249a66e4c19e85f439ff01e">&#9670;&nbsp;</a></span>vcm_is_on_feature_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FT , class VCMTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::vcm_is_on_feature_edge </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; FT, 6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VCMTraits&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/vcm_estimate_edges.h&gt;</code></p>
<p>determines if a point is on a sharp feature edge from a point set for which the Voronoi covariance Measures have been computed.</p>
<p>The sharpness of the edge, specified by parameter <code>threshold</code>, is used to filtered points according to the external angle around a sharp feature.</p>
<p>A point is considered to be on a sharp feature if the external angle <code>alpha</code> at the edge is such that <code>alpha &gt;= 2 / sqrt(3) * sqrt(threshold)</code>. In particular this means that if the input contains sharp features with different external angles, the one with the smallest external angle should be considered, which however would result in selecting more points on sharper regions. More details are provided in <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[11]</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VCMTraits</td><td>is a model of <code><a class="elRef" href="../Solver_interface/classDiagonalizeTraits.html">DiagonalizeTraits</a></code>. It can be omitted: if Eigen 3 (or greater) is available and <code>CGAL_EIGEN3_ENABLED</code> is defined then an overload using <code><a class="elRef" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">Eigen_diagonalize_traits</a></code> is provided. Otherwise, the internal implementation <code>Diagonalize_traits</code> is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4090777b535d58b5acf30ab7fb7cf488">CGAL::compute_vcm()</a>` </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Point_set_processing_3_2edges_example_8cpp-example.html#a6">Point_set_processing_3/edges_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gacbddbfa4e9c4c32c42d981a6a050d8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbddbfa4e9c4c32c42d981a6a050d8cd">&#9670;&nbsp;</a></span>wlop_simplify_and_regularize_point_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcurrencyTag , typename PointRange , typename OutputIterator , typename NamedParameters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator CGAL::wlop_simplify_and_regularize_point_set </td>
          <td>(</td>
          <td class="paramtype">PointRange &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp;&#160;</td>
          <td class="paramname"><em>np</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/wlop_simplify_and_regularize_point_set.h&gt;</code></p>
<p>This is an implementation of the Weighted Locally Optimal Projection (WLOP) simplification algorithm. The WLOP simplification algorithm can produce a set of denoised, outlier-free and evenly distributed particles over the original dense point cloud. The core of the algorithm is a Weighted Locally Optimal Projection operator with a density uniformization term. For more details, please refer to <a class="el" href="citelist.html#CITEREF_wlop-2009">[5]</a>.</p>
<p>A parallel version of WLOP is provided and requires the executable to be linked against the <a href="https://www.threadingbuildingblocks.org">Intel TBB library</a>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <a href="https://www.threadingbuildingblocks.org/documentation">TBB documentation</a> for more details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcurrencyTag</td><td>enables sequential versus parallel algorithm. Possible values are <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a></code>, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>, and <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">Parallel_if_available_tag</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. The value type of its iterator is the key type of the named parameter <code>point_map</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Type of the output iterator. It must accept objects of type <code>geom_traits::Point_3</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input point range. </td></tr>
    <tr><td class="paramname">output</td><td>iterator where output points are put. </td></tr>
    <tr><td class="paramname">np</td><td>optional sequence of <a class="el" href="group__psp__namedparameters.html">Named Parameters</a> among the ones listed below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Named Parameters</dt>
<dd><table class="params">
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_point_map">point_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Point_3</code>. If this parameter is omitted, <code><a class="elRef" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map</a>&lt;geom_traits::Point_3&gt;</code> is used. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_normal_map">normal_map</a></td><td>a model of <code>ReadWritePropertyMap</code> with value type <code>geom_traits::Vector_3</code>. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_select_percentage">select_percentage</a></td><td>percentage of points to retain. The default value is set to 5 (%). </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_neighbor_radius">neighbor_radius</a></td><td>spherical neighborhood radius. This is a key parameter that needs to be finely tuned. The result will be irregular if too small, but a larger value will impact the runtime. In practice, choosing a radius such that the neighborhood of each sample point includes at least two rings of neighboring sample points gives satisfactory result. If this parameter is not provided, it is automatically set to 8 times the average spacing of the point set. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_number_of_iterations">number_of_iterations</a></td><td>number of iterations to solve the optimsation problem. The default value is 35. More iterations give a more regular result but increase the runtime. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_require_uniform_sampling">require_uniform_sampling</a></td><td>an optional preprocessing, which will give better result if the distribution of the input points is highly non-uniform. The default value is <code>false</code>.  </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_callback">callback</a></td><td>an instance of <code>std::function&lt;bool(double)&gt;</code>. It is called regularly when the algorithm is running: the current advancement (between 0. and 1.) is passed as parameter. If it returns <code>true</code>, then the algorithm continues its execution normally; if it returns <code>false</code>, the algorithm is stopped, no output points are generated. </td></tr>
<tr>
<td class="paramname"><a class="el" href="group__psp__namedparameters.html#PSP_geom_traits">geom_traits</a></td><td>an instance of a geometric traits class, model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</div>
</body>
</html>
